Considered: 1) Mood DJ, 2) Campus Jam Finder, 3) FinTrack (chosen).
Chose FinTrack for recruiter relevance (fintech CRUD + analytics). Risks: useful charts, time-series aggregation. Next: seed categories and transactions.

wireframe: v1 covers login, dashboard with KPIs/charts, add-transaction core screen, empty/error state. Next: CSV export and budget alerts.

Branching Strategy - GitHub Flow with short-lived branches (wireframes-v1, feature/models, feature/charts). PRs into main.

Branch Usage Reflections - created wireframes-v1, added wireframes, opened PR, merged with descriptive message.

Django Setup - startproject: fintrack; startapp: tracker. Short, descriptive names.

Virtual Environment Choice - conda myenv-django in PyCharm for isolation and reproducibility.

Branch Usage Reflections - Created wireframes-v1, committed v1 wireframes, opened PR, and merged into main.

Branching Strategy - Using GitHub Flow with short-lived feature branches (wireframes-v1, feature/models, feature/charts). PRs into main; solo self-merge keeps main stable and history clear.

Django Setup - startproject: fintrack; startapp: tracker. Names are short and map to scope. Verified runserver locally.

Rationale for my model:
- Category (user, name, type) is unique per user/type; user=None supports global categories.
- Transaction FK to Category uses PROTECT to preserve history; FK to User uses CASCADE.
- Goal unique per (user, title) to avoid duplicates.
- Ordering - Transactions newest first; Categories by type/name; Goals by deadline.

Seeding the data (my reasoning) -
- 3 global categories (Food & Drinks, Rent, Salary) + 1 user category (Cozy Coffee).
- 7 transactions (mixed income/expenses). Verified uniqueness (duplicate Cozy Coffee rejected) and PROTECT (cannot delete used Rent).
