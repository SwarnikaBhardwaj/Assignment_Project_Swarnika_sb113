Considered: 1) Mood DJ, 2) Campus Jam Finder, 3) FinTrack (chosen).
Chose FinTrack for recruiter relevance (fintech CRUD + analytics). Risks: useful charts, time-series aggregation. Next: seed categories and transactions.

wireframe: v1 covers login, dashboard with KPIs/charts, add-transaction core screen, empty/error state. Next: CSV export and budget alerts.

Branching Strategy - GitHub Flow with short-lived branches (wireframes-v1, feature/models, feature/charts). PRs into main.

Branch Usage Reflections - created wireframes-v1, added wireframes, opened PR, merged with descriptive message.

Django Setup - startproject: fintrack; startapp: tracker. Short, descriptive names.

Virtual Environment Choice - conda myenv-django in PyCharm for isolation and reproducibility.

Branch Usage Reflections - Created wireframes-v1, committed v1 wireframes, opened PR, and merged into main.

Branching Strategy - Using GitHub Flow with short-lived feature branches (wireframes-v1, feature/models, feature/charts). PRs into main; solo self-merge keeps main stable and history clear.

Django Setup - startproject: fintrack; startapp: tracker. Names are short and map to scope. Verified runserver locally.

Rationale for my model:
- Category (user, name, type) is unique per user/type, user=None supports global categories.
- Transaction FK to Category uses PROTECT to preserve history, FK to User uses CASCADE.
- Goal unique per (user, title) to avoid duplicates.
- Ordering - Transactions newest first, categories by type/name, goals by deadline.

Seeding the data (my reasoning) -
- 3 global categories (Food & Drinks, Rent, Salary) and 1 user category (Cozy Coffee).
- 7 transactions (mixed income/expenses). Verified uniqueness (duplicate Cozy Coffee rejected) and PROTECT (cannot delete used Rent).

Relationships in my models (Cardinality)
- User 1 - *N* Category  (optional user scope, user=None = global categories)
- User 1 - *N* Transaction
- User 1 - *N* Goal
- Category 1 - *N* Transaction  (Transaction.category uses PROTECT to preserve history)
This demonstrates multiple **one-to-many** relationships (many-to-one at the DB level via ForeignKey).

For my views and templates (following MVT architecture shown in class)
- Wrote two views: First is HttpResponse + manual loader, second is render() shortcut
- Same template for both to show that templates are agnostic to how context is delivered
- URLs are /transactions/raw/ ( for HttpResponse) and /transactions/ (render). Added ?empty=1 helper to demonstrate {% empty %}
- Chose render() as the default going forward for readability and context processors

A5 - CBVs and URL refactor
- Base CBV has a manual get() so it basically manually query model and then pass context to template.
- Generic CBV has ListView so less boilerplate and then automatically passes object_list.
- Generic views help reduce code and I can see look like easier to maintain.
- URL refactor done through tracker app urls.py has all app routes and project urls.py only keeps admin.
- Templates extend base.html {% for %} loops with {% empty %} demonstrate empty states.



