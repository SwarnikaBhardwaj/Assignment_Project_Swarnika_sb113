Considered: 1) Mood DJ, 2) Campus Jam Finder, 3) FinTrack (chosen).
Chose FinTrack for recruiter relevance (fintech CRUD + analytics). Risks: useful charts, time-series aggregation. Next: seed categories and transactions.

wireframe: v1 covers login, dashboard with KPIs/charts, add-transaction core screen, empty/error state. Next: CSV export and budget alerts.

Branching Strategy - GitHub Flow with short-lived branches (wireframes-v1, feature/models, feature/charts). PRs into main.

Branch Usage Reflections - created wireframes-v1, added wireframes, opened PR, merged with descriptive message.

Django Setup - startproject: fintrack; startapp: tracker. Short, descriptive names.

Virtual Environment Choice - conda myenv-django in PyCharm for isolation and reproducibility.

Branch Usage Reflections - Created wireframes-v1, committed v1 wireframes, opened PR, and merged into main.

Branching Strategy - Using GitHub Flow with short-lived feature branches (wireframes-v1, feature/models, feature/charts). PRs into main; solo self-merge keeps main stable and history clear.

Django Setup - startproject: fintrack; startapp: tracker. Names are short and map to scope. Verified runserver locally.

Rationale for my model:
- Category (user, name, type) is unique per user/type, user=None supports global categories.
- Transaction FK to Category uses PROTECT to preserve history, FK to User uses CASCADE.
- Goal unique per (user, title) to avoid duplicates.
- Ordering - Transactions newest first, categories by type/name, goals by deadline.

Seeding the data (my reasoning) -
- 3 global categories (Food & Drinks, Rent, Salary) and 1 user category (Cozy Coffee).
- 7 transactions (mixed income/expenses). Verified uniqueness (duplicate Cozy Coffee rejected) and PROTECT (cannot delete used Rent).

Relationships in my models (Cardinality)
- User 1 - *N* Category  (optional user scope, user=None = global categories)
- User 1 - *N* Transaction
- User 1 - *N* Goal
- Category 1 - *N* Transaction  (Transaction.category uses PROTECT to preserve history)
This demonstrates multiple **one-to-many** relationships (many-to-one at the DB level via ForeignKey).

For my views and templates (following MVT architecture shown in class)
- Wrote two views: First is HttpResponse + manual loader, second is render() shortcut
- Same template for both to show that templates are agnostic to how context is delivered
- URLs are /transactions/raw/ ( for HttpResponse) and /transactions/ (render). Added ?empty=1 helper to demonstrate {% empty %}
- Chose render() as the default going forward for readability and context processors

A5 - CBVs and URL refactor
- Base CBV has a manual get() so it basically manually query model and then pass context to template.
- Generic CBV has ListView so less boilerplate and then automatically passes object_list.
- Generic views help reduce code and I can see look like easier to maintain.
- URL refactor done through tracker app urls.py has all app routes and project urls.py only keeps admin.
- Templates extend base.html {% for %} loops with {% empty %} demonstrate empty states.

A6 - Filtering and aggregation notes
- Learned that filtering narrows down querysets based on conditions
  - Used .filter() with Q objects for OR conditions (merchant or notes search)
  - Date range filtering with __gte and __lte lookups
  - Amount range filtering using Decimal comparison

- Aggregation computes summary statistics across querysets (some examples here are SUM, COUNT, AVG)
  - aggregate() returns a dictionry with overall stats like total, average
  - annotate() adds computed fields to each row in a grouped queryset
  - used Sum() to calculate total spending per category
  - used Count() to count transactions per merchant and per month

- Grouping is done with .values() followed by .annotate()
  - Category breakdown - i grouped by category__name, summed amounts
  - Top merchants - i grouped by merchant, counted transactions
  - Monthly trends - i used TruncMonth() to group by month, then summed

- All aggregations dynamically respond to filter parameters
  - Applied get_queryset() filters before computing aggregations
  - This shows filtered totals and not just overall totals

- Visual enhancements -  progress bars now show category spending as percentage of total (yay)
  - Calculated percentages in view context for template use
  - Color coded expenses so red vs income green (thank you Blake)

- Edge cases handled {% empty %} shows friendly message when no results
  - checks for None values in aggregations with "or 0" and "or Decimal('0.00')"
  - filter out empty merchant names before aggregating top merchants


