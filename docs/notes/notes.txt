Considered: 1) Mood DJ, 2) Campus Jam Finder, 3) FinTrack (chosen).
Chose FinTrack for recruiter relevance (fintech CRUD + analytics). Risks: useful charts, time-series aggregation. Next: seed categories and transactions.

wireframe: v1 covers login, dashboard with KPIs/charts, add-transaction core screen, empty/error state. Next: CSV export and budget alerts.

Branching Strategy - GitHub Flow with short-lived branches (wireframes-v1, feature/models, feature/charts). PRs into main.

Branch Usage Reflections - created wireframes-v1, added wireframes, opened PR, merged with descriptive message.

Django Setup - startproject: fintrack; startapp: tracker. Short, descriptive names.

Virtual Environment Choice - conda myenv-django in PyCharm for isolation and reproducibility.

Branch Usage Reflections - Created wireframes-v1, committed v1 wireframes, opened PR, and merged into main.

Branching Strategy - Using GitHub Flow with short-lived feature branches (wireframes-v1, feature/models, feature/charts). PRs into main; solo self-merge keeps main stable and history clear.

Django Setup - startproject: fintrack; startapp: tracker. Names are short and map to scope. Verified runserver locally.

Rationale for my model:
- Category (user, name, type) is unique per user/type, user=None supports global categories.
- Transaction FK to Category uses PROTECT to preserve history, FK to User uses CASCADE.
- Goal unique per (user, title) to avoid duplicates.
- Ordering - Transactions newest first, categories by type/name, goals by deadline.

Seeding the data (my reasoning) -
- 3 global categories (Food & Drinks, Rent, Salary) and 1 user category (Cozy Coffee).
- 7 transactions (mixed income/expenses). Verified uniqueness (duplicate Cozy Coffee rejected) and PROTECT (cannot delete used Rent).

Relationships in my models (Cardinality)
- User 1 - *N* Category  (optional user scope, user=None = global categories)
- User 1 - *N* Transaction
- User 1 - *N* Goal
- Category 1 - *N* Transaction  (Transaction.category uses PROTECT to preserve history)
This demonstrates multiple **one-to-many** relationships (many-to-one at the DB level via ForeignKey).

For my views and templates (following MVT architecture shown in class)
- Wrote two views: First is HttpResponse + manual loader, second is render() shortcut
- Same template for both to show that templates are agnostic to how context is delivered
- URLs are /transactions/raw/ ( for HttpResponse) and /transactions/ (render). Added ?empty=1 helper to demonstrate {% empty %}
- Chose render() as the default going forward for readability and context processors

A5 - CBVs and URL refactor
- Base CBV has a manual get() so it basically manually query model and then pass context to template.
- Generic CBV has ListView so less boilerplate and then automatically passes object_list.
- Generic views help reduce code and I can see look like easier to maintain.
- URL refactor done through tracker app urls.py has all app routes and project urls.py only keeps admin.
- Templates extend base.html {% for %} loops with {% empty %} demonstrate empty states.

A6 - Filtering and aggregation notes
- Learned that filtering narrows down querysets based on conditions
  - Used .filter() with Q objects for OR conditions (merchant or notes search)
  - Date range filtering with __gte and __lte lookups
  - Amount range filtering using Decimal comparison

- Aggregation computes summary statistics across querysets (some examples here are SUM, COUNT, AVG)
  - aggregate() returns a dictionry with overall stats like total, average
  - annotate() adds computed fields to each row in a grouped queryset
  - used Sum() to calculate total spending per category
  - used Count() to count transactions per merchant and per month

- Grouping is done with .values() followed by .annotate()
  - Category breakdown - i grouped by category__name, summed amounts
  - Top merchants - i grouped by merchant, counted transactions
  - Monthly trends - i used TruncMonth() to group by month, then summed

- All aggregations dynamically respond to filter parameters
  - Applied get_queryset() filters before computing aggregations
  - This shows filtered totals and not just overall totals

- Visual enhancements -  progress bars now show category spending as percentage of total (yay)
  - Calculated percentages in view context for template use
  - Color coded expenses so red vs income green (thank you Blake)

- Edge cases handled {% empty %} shows friendly message when no results
  - checks for None values in aggregations with "or 0" and "or Decimal('0.00')"
  - filter out empty merchant names before aggregating top merchants

A7 - Charts and static files notes
-Static files are configured at project root in static/tracker/ folder with CSS and images subfolders. STATICFILES_DIRS in settings.py tells Django to look in project level static directory during development. {% load static %} loads the static template tag library. {% static 'tracker/css/custom.css' %} generates URL path /static/tracker/css/custom.css for browser loading.
-Project level static at fintrack/static/ shared across apps while app level at app/static/app/ for my app specific assets. Using projectlevel for easier organization. In production collectstatic gathers all static files into STATIC_ROOT for web server serving. 2 matplotlib charts from real ORM aggregations and not hard coded data. Monthly bar chart uses annotate(month=TruncMonth('date')).values('month').annotate(total=Sum('amount')) grouping transactions by month. Category pie chart uses filter(category__type='EXPENSE').values('category__name').annotate(total=Sum('amount')) showing only expense categories.
-BytesIO creates inmemory bytes buffer acting like file in RAM. plt.savefig(buffer, format='png') writes chart to memory not disk. buffer.seek(0) resets read position to start for HttpResponse reading. More efficient than disk write/read and memory freed after request.
- tight_layout() adjusts subplot parameters preventing label cutoff. bbox_inches='tight' in savefig() crops excess whitespace. Combined they ensure professional charts with no truncated text.
-Chart views inherit View class returning HttpResponse with content_type='image/png' so browsers treat as images. URL patterns end .png but generated dynamically per request. Templates use {% url 'chart_monthly_spending' %} in img tags referencing dynamic endpoints. Charts auto-update when transaction data changes.
-Custom CSS uses Inter font from Google Fonts for modern typography. Enhanced card shadows with --card-shadow variable. Stat cards use gradient background matching navbar theme. Chart images display block width 100% for responsive sizing.
- all my aggregations use ORM queries from Transaction model. Overall stats use aggregate(total_transactions=Count('id'), total_spent=Sum('amount'), average_transaction=Avg('amount')) returning dictionary. Monthly uses TruncMonth() converting dates to month grouping. Category breakdown uses values('category__name').annotate(total=Sum('amount')) with double underscore traversing foreign key.
Save.

A8 - GET, POST and forms
- CSRF stands for Cross Site Request Forgery amd its an attack where a bad website tricks your browser into submitting forms to other sites youre logged into. I added it with the csrf_token tag in templates
- Form submission is done through:
- User visits form page Django shows empty form using get request -> user fills out form and clicks submit browser sends POST request with form data->Django view receives the data and creates a form instance with request dot POST->view calls form dot is_valid which runs all validation rules->if valid Django processes the data saves to database ->if invalid Django re renders the form with error messages shown next to problem fields
- FBV pros you can see all the logic in one place easier to debug easier for beginners to understand more flexible for complex logic
- FBV cons more repetitive code you have to write if request dot method equals POST yourself have to handle GET and POST manually
- CBV pros much less code Django handles GET POST automatically built in methods like form_valid easier to reuse code
- Use GET when youre searching filtering or reading data because GET puts data in URL which can be bookmarked and shared
- Use POST when youre creating updating or deleting data because POST hides data from URL and includes CSRF protection
- GET requests should never modify database only read from it

A9 - APIS and charts
What is a json api: its basically a url that returns data instead of html, the data is in json format which is like a python dictionary but in text form.
- anyone can hit that url and get the data
- way better than html because programs can easily parse json but parsing html is a nightmare :(
httpresponse vs jsonresponse
- httpresponse is the basic response class in django - it just returns whatever content you give it
- jsonresponse is a subclass that makes json specifically, it automatically converts your python dict to json text
- basically jsonresponse does all the json things for you so you dont have to remember
how the chart view works
- this was actually pretty clever once i understood it. my chart view uses urllib to make an http request to my own api
- it fetches the json data, parses it with json.loads, then extracts the numbers and category names, uses matplotlib to draw a bar chart just like we did before and returns the chart as a png image
- so the data flow is  database → api view returns json → chart view fetches that json → makes chart → returns png

A10 - External APIs
what api I picked and why
- I used the exchangerate-api.com currency converter api. made sense for fintrack because if someone travels or buys stuff internationally they might want to see prices in different currencies
- its completely free and doesnt need an api key which was nice - returns json with exchange rates for like 160 currencies. the base url is https://api.exchangerate-api.com/v4/latest/USD and it gives you rates relative to USD
what I pulled from the API
- base currency (USD in my case), the rates dictionary which has all the exchange rates, the date when rates were last updated
- I specifically pull out just the target currency rate the user asked for instead of returning all 160 currencies. my cleaned response has: original amount, target currency, exchange rate, converted amount, and last updated date
how i handled errors and timeouts
- used timeout equals 5 in the requests.get call so it doesnt hang forever if the api is slow
- wrapped everything in try except blocks to catch different error types, used response.raise_for_status too
- also validated the amount parameter to make sure its actually a number before calling the api
what the final json looks like
- {"ok": true, "original_amount": 100, "original_currency": "USD", "target_currency": "EUR", "exchange_rate": 0.92, "converted_amount": 92.0, "last_updated": "2024-10-23"}
- if theres an error it looks like: {"ok": false, "error": "Amount must be a valid number"}
api limitations and quirks I noticed
- the api updates rates once per day not in real time so if you check multiple times you get the same rates
- if you request a currency that doesnt exist the api still returns 200 but that currency just wont be in the rates dict so i had to check for that
- to do: include the ability to change the currency you want to convert from (and not hardcode it)

A11 - Auth and Downloading reports
how i generated csv and json files
- for csv used pythons csv.writer writing directly to httpresponse with content_type text/csv
- for json built list of dicts then used jsonresponse with indent equals 2 for pretty formatting
- both get timestamped filenames using datetime.now with strftime so you can tell them apart
what metadata and columns are included
- csv has id, merchant, amount, category name, date, notes ordered by date descending
- json has same fields wrapped in transactions array plus generated_at timestamp and record_count
- used select_related for category to avoid n plus 1 query problem
what summaries appear on reports page
- spending by category shows total spent and transaction count per category sorted by highest spending
- monthly spending shows last 6 months with total and count per month
- three stat cards at top show overall transaction count, total spent, and average transaction amount
what authentication protects and why it matters
- authentication protects all transaction data, reports, charts, and exports so random people cant see your financial information
what loginrequiredmixin and login_required do
- login_required decorator and loginrequiredmixin check if users are logged in and redirect to login page if not
purpose of the next query parameter
- next parameter remembers which page you were trying to visit so after login it takes you back there instead of a generic page
auth related settings
- login_url is login, login_redirect_url is reports, logout_redirect_url is login in settings.py
how i ensure new users are non staff non superuser
- in signup view i explicitly set is_staff and is_superuser to false after creating the user to prevent admin access