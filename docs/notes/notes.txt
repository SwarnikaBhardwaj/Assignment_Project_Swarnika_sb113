Considered: 1) Mood DJ, 2) Campus Jam Finder, 3) FinTrack (chosen).
Chose FinTrack for recruiter relevance (fintech CRUD + analytics). Risks: useful charts, time-series aggregation. Next: seed categories and transactions.

wireframe: v1 covers login, dashboard with KPIs/charts, add-transaction core screen, empty/error state. Next: CSV export and budget alerts.

Branching Strategy - GitHub Flow with short-lived branches (wireframes-v1, feature/models, feature/charts). PRs into main.

Branch Usage Reflections - created wireframes-v1, added wireframes, opened PR, merged with descriptive message.

Django Setup - startproject: fintrack; startapp: tracker. Short, descriptive names.

Virtual Environment Choice - conda myenv-django in PyCharm for isolation and reproducibility.

Branch Usage Reflections - Created wireframes-v1, committed v1 wireframes, opened PR, and merged into main.

Branching Strategy - Using GitHub Flow with short-lived feature branches (wireframes-v1, feature/models, feature/charts). PRs into main; solo self-merge keeps main stable and history clear.

Django Setup - startproject: fintrack; startapp: tracker. Names are short and map to scope. Verified runserver locally.

Rationale for my model:
- Category (user, name, type) is unique per user/type, user=None supports global categories.
- Transaction FK to Category uses PROTECT to preserve history, FK to User uses CASCADE.
- Goal unique per (user, title) to avoid duplicates.
- Ordering - Transactions newest first, categories by type/name, goals by deadline.

Seeding the data (my reasoning) -
- 3 global categories (Food & Drinks, Rent, Salary) and 1 user category (Cozy Coffee).
- 7 transactions (mixed income/expenses). Verified uniqueness (duplicate Cozy Coffee rejected) and PROTECT (cannot delete used Rent).

Relationships in my models (Cardinality)
- User 1 - *N* Category  (optional user scope, user=None = global categories)
- User 1 - *N* Transaction
- User 1 - *N* Goal
- Category 1 - *N* Transaction  (Transaction.category uses PROTECT to preserve history)
This demonstrates multiple **one-to-many** relationships (many-to-one at the DB level via ForeignKey).

For my views and templates (following MVT architecture shown in class)
- Wrote two views: First is HttpResponse + manual loader, second is render() shortcut
- Same template for both to show that templates are agnostic to how context is delivered
- URLs are /transactions/raw/ ( for HttpResponse) and /transactions/ (render). Added ?empty=1 helper to demonstrate {% empty %}
- Chose render() as the default going forward for readability and context processors

A5 - CBVs and URL refactor
- Base CBV has a manual get() so it basically manually query model and then pass context to template.
- Generic CBV has ListView so less boilerplate and then automatically passes object_list.
- Generic views help reduce code and I can see look like easier to maintain.
- URL refactor done through tracker app urls.py has all app routes and project urls.py only keeps admin.
- Templates extend base.html {% for %} loops with {% empty %} demonstrate empty states.

A6 - Filtering and aggregation notes
- Learned that filtering narrows down querysets based on conditions
  - Used .filter() with Q objects for OR conditions (merchant or notes search)
  - Date range filtering with __gte and __lte lookups
  - Amount range filtering using Decimal comparison

- Aggregation computes summary statistics across querysets (some examples here are SUM, COUNT, AVG)
  - aggregate() returns a dictionry with overall stats like total, average
  - annotate() adds computed fields to each row in a grouped queryset
  - used Sum() to calculate total spending per category
  - used Count() to count transactions per merchant and per month

- Grouping is done with .values() followed by .annotate()
  - Category breakdown - i grouped by category__name, summed amounts
  - Top merchants - i grouped by merchant, counted transactions
  - Monthly trends - i used TruncMonth() to group by month, then summed

- All aggregations dynamically respond to filter parameters
  - Applied get_queryset() filters before computing aggregations
  - This shows filtered totals and not just overall totals

- Visual enhancements -  progress bars now show category spending as percentage of total (yay)
  - Calculated percentages in view context for template use
  - Color coded expenses so red vs income green (thank you Blake)

- Edge cases handled {% empty %} shows friendly message when no results
  - checks for None values in aggregations with "or 0" and "or Decimal('0.00')"
  - filter out empty merchant names before aggregating top merchants

A7 - Static files and charts
- Static files configured at project root level in static/ folder with structure static/tracker/css/, static/tracker/images/. STATICFILES_DIRS in settings.py points Django to the projeclevel static folder so it searches there during development. {% load static %} at the top of any template that uses static files. {% static 'tracker/css/custom.css' %} generates the full URL path /static/tracker/css/custom.css which the browser can load.
- Projectlevel static files at fintrack/static/ are shared across all apps, while applevel static files at app/static/app/ are app specific. used project level for easier organization and the ability to share assets. In production collectstatic gathers files from both STATICFILES_DIRS and app static folders into STATIC_ROOT for serving by nginx or another web server.
- also created two Matplotlib charts generated from real database aggregations not hard coded data. Monthly spending bar chart uses annotate(month=TruncMonth('date')).values('month').annotate(total=Sum('amount'), count=Count('id')).order_by('month') to group transactions by month and sum amounts. Category pie chart uses values('category__name', 'category__type').annotate(total=Sum('amount')).order_by('-total') to group by category and compute totals.
- used tight_layout() in matplotlib which sorta adjusts subplot parameters so that labels, titles, and tick labels fit within the figure area without being cut off. bbox_inches='tight' in savefig() further crops any excess whitespace around the chart edges. Together these ensure the generated PNG looks professional with no truncated text or excessive margins.
- my chart views inherit from Django's View class and return HttpResponse with content_type='image/png' so browsers treat the response as an image file. The URL patterns end in .png but the images are generated dynamically on each request. Template <img> tags use {% url 'chart_monthly_spending' %} to reference these dynamic chart endpoints, and charts automatically update when underlying transaction data changes.

