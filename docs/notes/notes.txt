Considered: 1) Mood DJ, 2) Campus Jam Finder, 3) FinTrack (chosen).
Chose FinTrack for recruiter relevance (fintech CRUD + analytics). Risks: useful charts, time-series aggregation. Next: seed categories and transactions.

wireframe: v1 covers login, dashboard with KPIs/charts, add-transaction core screen, empty/error state. Next: CSV export and budget alerts.

Branching Strategy - GitHub Flow with short-lived branches (wireframes-v1, feature/models, feature/charts). PRs into main.

Branch Usage Reflections - created wireframes-v1, added wireframes, opened PR, merged with descriptive message.

Django Setup - startproject: fintrack; startapp: tracker. Short, descriptive names.

Virtual Environment Choice - conda myenv-django in PyCharm for isolation and reproducibility.

Branch Usage Reflections - Created wireframes-v1, committed v1 wireframes, opened PR, and merged into main.

Branching Strategy - Using GitHub Flow with short-lived feature branches (wireframes-v1, feature/models, feature/charts). PRs into main; solo self-merge keeps main stable and history clear.

Django Setup - startproject: fintrack; startapp: tracker. Names are short and map to scope. Verified runserver locally.

Rationale for my model:
- Category (user, name, type) is unique per user/type, user=None supports global categories.
- Transaction FK to Category uses PROTECT to preserve history, FK to User uses CASCADE.
- Goal unique per (user, title) to avoid duplicates.
- Ordering - Transactions newest first, categories by type/name, goals by deadline.

Seeding the data (my reasoning) -
- 3 global categories (Food & Drinks, Rent, Salary) and 1 user category (Cozy Coffee).
- 7 transactions (mixed income/expenses). Verified uniqueness (duplicate Cozy Coffee rejected) and PROTECT (cannot delete used Rent).

Relationships in my models (Cardinality)
- User 1 - *N* Category  (optional user scope, user=None = global categories)
- User 1 - *N* Transaction
- User 1 - *N* Goal
- Category 1 - *N* Transaction  (Transaction.category uses PROTECT to preserve history)
This demonstrates multiple **one-to-many** relationships (many-to-one at the DB level via ForeignKey).

For my views and templates (following MVT architecture shown in class)
- Wrote two views: First is HttpResponse + manual loader, second is render() shortcut
- Same template for both to show that templates are agnostic to how context is delivered
- URLs are /transactions/raw/ ( for HttpResponse) and /transactions/ (render). Added ?empty=1 helper to demonstrate {% empty %}
- Chose render() as the default going forward for readability and context processors

A5 - CBVs and URL refactor
- Base CBV has a manual get() so it basically manually query model and then pass context to template.
- Generic CBV has ListView so less boilerplate and then automatically passes object_list.
- Generic views help reduce code and I can see look like easier to maintain.
- URL refactor done through tracker app urls.py has all app routes and project urls.py only keeps admin.
- Templates extend base.html {% for %} loops with {% empty %} demonstrate empty states.

A6 - Filtering and aggregation notes
- Learned that filtering narrows down querysets based on conditions
  - Used .filter() with Q objects for OR conditions (merchant or notes search)
  - Date range filtering with __gte and __lte lookups
  - Amount range filtering using Decimal comparison

- Aggregation computes summary statistics across querysets (some examples here are SUM, COUNT, AVG)
  - aggregate() returns a dictionry with overall stats like total, average
  - annotate() adds computed fields to each row in a grouped queryset
  - used Sum() to calculate total spending per category
  - used Count() to count transactions per merchant and per month

- Grouping is done with .values() followed by .annotate()
  - Category breakdown - i grouped by category__name, summed amounts
  - Top merchants - i grouped by merchant, counted transactions
  - Monthly trends - i used TruncMonth() to group by month, then summed

- All aggregations dynamically respond to filter parameters
  - Applied get_queryset() filters before computing aggregations
  - This shows filtered totals and not just overall totals

- Visual enhancements -  progress bars now show category spending as percentage of total (yay)
  - Calculated percentages in view context for template use
  - Color coded expenses so red vs income green (thank you Blake)

- Edge cases handled {% empty %} shows friendly message when no results
  - checks for None values in aggregations with "or 0" and "or Decimal('0.00')"
  - filter out empty merchant names before aggregating top merchants

A7 - Charts and static files notes
-Static files are configured at project root in static/tracker/ folder with CSS and images subfolders. STATICFILES_DIRS in settings.py tells Django to look in project level static directory during development. {% load static %} loads the static template tag library. {% static 'tracker/css/custom.css' %} generates URL path /static/tracker/css/custom.css for browser loading.
-Project level static at fintrack/static/ shared across apps while app level at app/static/app/ for my app specific assets. Using projectlevel for easier organization. In production collectstatic gathers all static files into STATIC_ROOT for web server serving. 2 matplotlib charts from real ORM aggregations and not hard coded data. Monthly bar chart uses annotate(month=TruncMonth('date')).values('month').annotate(total=Sum('amount')) grouping transactions by month. Category pie chart uses filter(category__type='EXPENSE').values('category__name').annotate(total=Sum('amount')) showing only expense categories.
-BytesIO creates inmemory bytes buffer acting like file in RAM. plt.savefig(buffer, format='png') writes chart to memory not disk. buffer.seek(0) resets read position to start for HttpResponse reading. More efficient than disk write/read and memory freed after request.
- tight_layout() adjusts subplot parameters preventing label cutoff. bbox_inches='tight' in savefig() crops excess whitespace. Combined they ensure professional charts with no truncated text.
-Chart views inherit View class returning HttpResponse with content_type='image/png' so browsers treat as images. URL patterns end .png but generated dynamically per request. Templates use {% url 'chart_monthly_spending' %} in img tags referencing dynamic endpoints. Charts auto-update when transaction data changes.
-Custom CSS uses Inter font from Google Fonts for modern typography. Enhanced card shadows with --card-shadow variable. Stat cards use gradient background matching navbar theme. Chart images display block width 100% for responsive sizing.
- all my aggregations use ORM queries from Transaction model. Overall stats use aggregate(total_transactions=Count('id'), total_spent=Sum('amount'), average_transaction=Avg('amount')) returning dictionary. Monthly uses TruncMonth() converting dates to month grouping. Category breakdown uses values('category__name').annotate(total=Sum('amount')) with double underscore traversing foreign key.
Save.

A8 - GET, POST and forms
- CSRF stands for Cross Site Request Forgery amd its an attack where a bad website tricks your browser into submitting forms to other sites youre logged into. I added it with the csrf_token tag in templates
- Form submission is done through:
- User visits form page Django shows empty form using get request -> user fills out form and clicks submit browser sends POST request with form data->Django view receives the data and creates a form instance with request dot POST->view calls form dot is_valid which runs all validation rules->if valid Django processes the data saves to database ->if invalid Django re renders the form with error messages shown next to problem fields
- FBV pros you can see all the logic in one place easier to debug easier for beginners to understand more flexible for complex logic
- FBV cons more repetitive code you have to write if request dot method equals POST yourself have to handle GET and POST manually
- CBV pros much less code Django handles GET POST automatically built in methods like form_valid easier to reuse code
- Use GET when youre searching filtering or reading data because GET puts data in URL which can be bookmarked and shared
- Use POST when youre creating updating or deleting data because POST hides data from URL and includes CSRF protection
- GET requests should never modify database only read from it

A9 - APIS and charts
What is a json api: its basically a url that returns data instead of html, the data is in json format which is like a python dictionary but in text form.
- anyone can hit that url and get the data
- way better than html because programs can easily parse json but parsing html is a nightmare :(
httpresponse vs jsonresponse
- httpresponse is the basic response class in django - it just returns whatever content you give it
- jsonresponse is a subclass that makes json specifically, it automatically converts your python dict to json text
- basically jsonresponse does all the json things for you so you dont have to remember
how the chart view works
- this was actually pretty clever once i understood it. my chart view uses urllib to make an http request to my own api
- it fetches the json data, parses it with json.loads, then extracts the numbers and category names, uses matplotlib to draw a bar chart just like we did before and returns the chart as a png image
- so the data flow is  database → api view returns json → chart view fetches that json → makes chart → returns png

